# 后端高级功能测试说明

## 📋 测试前准备

### 步骤1: 启动MySQL数据库并创建数据库

#### 1.1 启动MySQL服务

**Windows系统**:
```bash
# 方法1: 使用服务管理器
# 按 Win+R，输入 services.msc，找到MySQL服务，右键启动

# 方法2: 使用命令行（以管理员身份运行）
net start MySQL80
# 或者（根据你的MySQL服务名称）
net start MySQL
```

**验证MySQL是否运行**:
```bash
# 打开命令行，输入
mysql --version
# 如果显示版本号，说明MySQL已安装
```

#### 1.2 连接到MySQL并创建数据库

```bash
# 使用命令行连接MySQL（根据你的MySQL配置）
mysql -u root -p
# 输入密码（默认配置中的密码是: 131441051a）
```

**或者使用MySQL Workbench/Navicat等图形化工具**:
- 连接到本地MySQL服务器
- 用户名: `root`
- 密码: `131441051a`（根据你的实际配置修改）

#### 1.3 执行SQL脚本创建数据库和表

**方法1: 使用命令行**
```bash
# 在项目根目录执行
mysql -u root -p < test_data.sql
# 输入密码: 131441051a
```

**方法2: 使用MySQL客户端工具**
1. 打开MySQL Workbench或Navicat
2. 连接到MySQL服务器
3. 打开 `test_data.sql` 文件
4. 执行整个脚本

**方法3: 手动执行**
```sql
-- 1. 创建数据库
CREATE DATABASE IF NOT EXISTS learning_db DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
USE learning_db;

-- 2. 执行test_data.sql中的所有SQL语句
-- （复制test_data.sql文件内容，在MySQL客户端中执行）
```

**验证数据库创建成功**:
```sql
-- 在MySQL中执行
USE learning_db;
SHOW TABLES;
-- 应该看到: users, questions, answers, resources 四个表

SELECT COUNT(*) FROM users;
-- 应该返回: 8（8个测试用户）
```

#### 1.4 创建全文搜索索引（重要！）

为了支持搜索功能，需要为questions表创建FULLTEXT索引：

```sql
USE learning_db;

-- 为questions表的title和content字段创建全文索引
ALTER TABLE questions ADD FULLTEXT INDEX ft_title_content (title, content);
```

**验证索引创建**:
```sql
SHOW INDEX FROM questions;
-- 应该能看到 ft_title_content 索引
```

---

### 步骤2: 启动Redis服务

#### 2.1 Windows系统启动Redis

**方法1: 使用Redis官方Windows版本**
1. 下载Redis for Windows: https://github.com/microsoftarchive/redis/releases
2. 解压到某个目录（如 `C:\Redis`）
3. 打开命令行，进入Redis目录
4. 运行: `redis-server.exe`
5. 看到 `Ready to accept connections` 表示启动成功

**方法2: 使用WSL（Windows Subsystem for Linux）**
```bash
# 在WSL中安装Redis
sudo apt-get update
sudo apt-get install redis-server

# 启动Redis
sudo service redis-server start

# 验证Redis运行
redis-cli ping
# 应该返回: PONG
```

**方法3: 使用Docker（推荐）**
```bash
# 如果已安装Docker
docker run -d -p 6379:6379 --name redis redis:latest

# 验证Redis运行
docker ps
# 应该能看到redis容器在运行
```

#### 2.2 验证Redis连接

```bash
# 打开新的命令行窗口
redis-cli

# 在Redis CLI中测试
ping
# 应该返回: PONG

# 测试设置和获取
set test "hello"
get test
# 应该返回: "hello"

exit
```

**如果Redis不在默认端口6379**:
- 修改 `backend/src/main/resources/application.properties` 中的Redis端口配置

---

### 步骤3: 配置和启动后端服务

#### 3.1 检查配置文件

打开 `backend/src/main/resources/application.properties`，确认以下配置：

```properties
# 服务器端口
server.port=8081

# MySQL数据库配置（根据你的实际情况修改）
spring.datasource.url=jdbc:mysql://localhost:3306/learning_db?useSSL=false&serverTimezone=UTC&characterEncoding=utf8
spring.datasource.username=root
spring.datasource.password=131441051a  # 修改为你的MySQL密码

# Redis配置（根据你的实际情况修改）
spring.redis.host=localhost
spring.redis.port=6379
spring.redis.password=  # 如果Redis有密码，填写密码
spring.redis.database=0
```

#### 3.2 使用Maven启动后端服务

**方法1: 使用IDE（推荐）**
1. 使用IntelliJ IDEA或Eclipse打开项目
2. 找到 `backend/src/main/java/com/example/app/Application.java`
3. 右键点击 `Application.java`，选择 `Run 'Application.main()'`
4. 等待启动完成，看到类似以下日志表示启动成功：
   ```
   Started Application in X.XXX seconds
   ```

**方法2: 使用Maven命令行**
```bash
# 1. 打开命令行，进入backend目录
cd backend

# 2. 编译项目（首次运行）
mvn clean compile

# 3. 启动服务
mvn spring-boot:run

# 或者打包后运行
mvn clean package
java -jar target/learning-community-1.0.0.jar
```

**方法3: 使用打包后的JAR文件**
```bash
# 1. 打包项目
cd backend
mvn clean package

# 2. 运行JAR文件
java -jar target/learning-community-1.0.0.jar
```

#### 3.3 验证后端服务启动成功

**检查日志输出**:
- 应该看到 `Started Application in X.XXX seconds`
- 应该看到 `Tomcat started on port(s): 8081`
- 不应该有错误信息

**使用浏览器测试**:
```
访问: http://localhost:8081/api/questions
应该能看到问题列表的JSON响应
```

**使用命令行测试**:
```bash
# Windows PowerShell
curl http://localhost:8081/api/questions

# 或者使用Postman发送GET请求到 http://localhost:8081/api/questions
```

---

### 步骤4: 准备测试数据

#### 4.1 确认测试数据已导入

如果已经执行了 `test_data.sql`，测试数据应该已经准备好了。

**验证测试数据**:
```sql
USE learning_db;

-- 查看用户数据
SELECT id, email, nickname, role FROM users;
-- 应该有8个用户

-- 查看问题数据
SELECT id, user_id, title, status FROM questions;
-- 应该有6个问题

-- 查看回答数据
SELECT id, question_id, user_id, is_best FROM answers;
-- 应该有8个回答
```

#### 4.2 创建额外的测试数据（可选）

如果需要更多测试数据来测试搜索功能：

```sql
USE learning_db;

-- 插入更多包含不同关键词的问题
INSERT INTO questions (user_id, title, content, status) VALUES
(3, 'Java多线程编程实践', '如何正确使用Java多线程？需要注意哪些问题？', 'APPROVED'),
(4, 'Python数据分析入门', '使用Python进行数据分析的常用库有哪些？', 'APPROVED'),
(5, 'Spring Boot微服务架构', '如何用Spring Boot构建微服务？', 'APPROVED'),
(6, 'MySQL索引优化技巧', 'MySQL索引的设计和优化有哪些最佳实践？', 'APPROVED');
```

---

### 步骤5: 导入Postman集合

1. **打开Postman**
   - 如果没有安装，从 https://www.postman.com/downloads/ 下载安装

2. **导入集合文件**
   - 打开Postman
   - 点击左上角的 `Import` 按钮
   - 选择项目根目录下的 `postman_collection.json` 文件
   - 点击 `Import`

3. **验证导入成功**
   - 左侧应该能看到"学习平台API测试"集合
   - 展开后应该能看到以下文件夹：
     - 身份验证
     - 用户管理
     - 问题管理
     - 回答管理
     - 资源管理
     - 管理员功能
     - **通知功能**（新增）
     - **搜索功能**（新增）

---

## ✅ 准备完成检查清单

在开始测试前，请确认以下所有项都已完成：

- [ ] MySQL服务已启动
- [ ] `learning_db` 数据库已创建
- [ ] 数据库表已创建（users, questions, answers, resources）
- [ ] 测试数据已导入（至少8个用户，6个问题，8个回答）
- [ ] questions表已创建FULLTEXT索引（`ft_title_content`）
- [ ] Redis服务已启动
- [ ] Redis连接测试成功（`redis-cli ping` 返回 PONG）
- [ ] 后端服务已启动（端口8081）
- [ ] 后端服务可以访问（`http://localhost:8081/api/questions` 返回数据）
- [ ] Postman集合已导入
- [ ] 配置文件中的数据库密码和Redis配置已正确设置

**如果所有项都已完成，可以开始测试了！** 🎉

---

## 🔔 一、实时通知功能测试

### 1.1 REST API接口测试（可用Postman测试）

#### ✅ 获取所有通知
- **接口**: `GET /notifications`
- **说明**: 获取系统中存储的所有通知（注意：当前实现返回的是内存中的列表）

#### ✅ 发送通知（测试用）
- **接口**: `POST /notifications`
- **请求体**:
```json
{
  "userId": 3,
  "type": "TEST_NOTIFICATION",
  "message": "这是一条测试通知",
  "timestamp": "2024-01-01T10:00:00"
}
```

#### ✅ 获取用户离线通知
- **接口**: `GET /notifications/offline/{userId}`
- **示例**: `GET /notifications/offline/3`
- **说明**: 获取指定用户的离线通知，获取后会自动清空该用户的离线通知队列

### 1.2 事件驱动通知测试（通过触发其他操作）

#### ✅ 测试回答创建触发通知
**测试步骤**:
1. 先创建一个问题（使用"问题管理 > 创建新问题"），假设问题ID为1，创建者userId=3
2. 使用另一个用户（userId=4）创建回答（使用"回答管理 > 创建回答"）
   - 请求体: `{"questionId": 1, "userId": 4, "content": "测试回答"}`
3. 调用 `GET /notifications/offline/3` 获取问题创建者的离线通知
4. **预期结果**: 应该能看到一条类型为"NEW_ANSWER"的通知

#### ✅ 测试点赞触发通知
**测试步骤**:
1. 确保存在一个回答（回答ID=1），且回答创建者不是userId=3
2. 使用userId=3点赞该回答（使用"回答管理 > 点赞回答"）
3. 调用 `GET /notifications/offline/{回答创建者userId}` 获取离线通知
4. **预期结果**: 应该能看到一条类型为"ANSWER_LIKED"的通知

#### ✅ 测试标记最佳答案触发通知
**测试步骤**:
1. 确保存在一个问题（问题ID=1），创建者为userId=3
2. 确保存在一个回答（回答ID=1），属于该问题
3. 使用问题创建者（userId=3）标记该回答为最佳答案（使用"回答管理 > 标记最佳答案"）
4. 调用 `GET /notifications/offline/{回答创建者userId}` 获取离线通知
5. **预期结果**: 应该能看到一条类型为"BEST_ANSWER"的通知

### 1.3 WebSocket实时通信测试（⚠️ Postman限制说明）

**重要提示**: Postman的免费版本不支持WebSocket测试。需要使用以下方法之一：

#### 方法1: 使用Postman的WebSocket功能（需要Postman Pro/Enterprise）
1. 在Postman中创建新的WebSocket请求
2. URL: `ws://localhost:8081/ws/notifications?userId=3`
3. 连接后，当有通知发送给userId=3时，会实时收到消息

#### 方法2: 使用浏览器控制台测试
```javascript
// 在浏览器控制台中执行
const ws = new WebSocket('ws://localhost:8081/ws/notifications?userId=3');

ws.onopen = () => {
    console.log('WebSocket连接成功');
};

ws.onmessage = (event) => {
    const notification = JSON.parse(event.data);
    console.log('收到通知:', notification);
};

ws.onerror = (error) => {
    console.error('WebSocket错误:', error);
};

ws.onclose = () => {
    console.log('WebSocket连接关闭');
};

// 测试心跳
ws.send('PING'); // 应该收到 'PONG' 响应
```

#### 方法3: 使用在线WebSocket测试工具
- 访问 https://www.websocket.org/echo.html
- 或使用其他WebSocket客户端工具
- 连接地址: `ws://localhost:8081/ws/notifications?userId=3`

#### WebSocket测试流程
1. **建立连接**: 使用上述任一方法连接到WebSocket端点
2. **触发通知**: 在Postman中执行以下操作之一：
   - 创建回答（会触发通知给问题创建者）
   - 点赞回答（会触发通知给回答创建者）
   - 标记最佳答案（会触发通知给回答创建者）
3. **验证实时推送**: 如果目标用户在线（已建立WebSocket连接），应该立即收到通知消息
4. **验证离线存储**: 如果目标用户离线（未建立WebSocket连接），通知会存储在Redis中，可以通过 `GET /notifications/offline/{userId}` 获取

---

## 🔍 二、关键字检索功能测试

### 2.1 基本搜索测试

#### ✅ 基本搜索（默认排序）
- **接口**: `GET /search?keyword=Java&page=1&size=10`
- **说明**: 搜索包含"Java"关键词的问题，默认按创建时间降序排序
- **预期结果**: 返回包含"Java"的问题列表，按创建时间从新到旧排列

### 2.2 排序功能测试

#### ✅ 按创建时间降序排序
- **接口**: `GET /search?keyword=Java&page=1&size=10&orderBy=create_time&orderDirection=DESC`
- **预期结果**: 最新创建的问题在前

#### ✅ 按创建时间升序排序
- **接口**: `GET /search?keyword=Java&page=1&size=10&orderBy=create_time&orderDirection=ASC`
- **预期结果**: 最早创建的问题在前

#### ✅ 按标题排序
- **接口**: `GET /search?keyword=Java&page=1&size=10&orderBy=title&orderDirection=ASC`
- **预期结果**: 按标题字母顺序排列

### 2.3 分页功能测试

#### ✅ 分页测试
- **接口**: `GET /search?keyword=测试&page=2&size=5`
- **说明**: 获取第2页，每页5条记录
- **预期结果**: 返回第2页的数据（第6-10条记录）

### 2.4 搜索范围测试

**测试步骤**:
1. 创建一些测试问题，标题和内容中包含不同的关键词
2. 使用搜索接口搜索这些关键词
3. **预期结果**: 
   - 搜索应该同时匹配标题和内容
   - 返回完整的Question对象（包含id, userId, title, content, status, createTime等字段）

---

## 🧪 三、完整测试流程示例

### 场景1: 测试回答创建通知的完整流程

1. **准备数据**:
   - 创建问题: `POST /api/questions` (userId=3, title="如何学习Java?")
   - 记录问题ID（假设为1）

2. **建立WebSocket连接**（使用浏览器控制台）:
   ```javascript
   const ws = new WebSocket('ws://localhost:8081/ws/notifications?userId=3');
   ws.onmessage = (e) => console.log('通知:', JSON.parse(e.data));
   ```

3. **触发通知**:
   - 创建回答: `POST /api/answers` (questionId=1, userId=4, content="多练习")

4. **验证结果**:
   - 如果WebSocket连接正常，应该立即在控制台看到通知
   - 或者调用 `GET /notifications/offline/3` 查看离线通知

### 场景2: 测试搜索功能的完整流程

1. **准备测试数据**:
   - 创建多个问题，包含不同的关键词（如"Java"、"Python"、"测试"等）

2. **测试基本搜索**:
   - `GET /search?keyword=Java&page=1&size=10`
   - 验证返回的问题都包含"Java"关键词

3. **测试排序**:
   - `GET /search?keyword=Java&page=1&size=10&orderBy=create_time&orderDirection=DESC`
   - 验证结果按创建时间降序排列

4. **测试分页**:
   - `GET /search?keyword=Java&page=1&size=5` (第1页)
   - `GET /search?keyword=Java&page=2&size=5` (第2页)
   - 验证两页的数据不重复且连续

---

## 📝 四、测试检查清单

### 通知功能检查清单
- [ ] 可以获取所有通知
- [ ] 可以发送测试通知
- [ ] 可以获取用户离线通知
- [ ] 创建回答时触发通知（验证离线通知）
- [ ] 点赞回答时触发通知（验证离线通知）
- [ ] 标记最佳答案时触发通知（验证离线通知）
- [ ] WebSocket连接成功
- [ ] WebSocket实时接收通知（需要WebSocket客户端）

### 搜索功能检查清单
- [ ] 基本搜索功能正常
- [ ] 搜索结果包含完整Question对象
- [ ] 按创建时间降序排序正常
- [ ] 按创建时间升序排序正常
- [ ] 按标题排序正常
- [ ] 分页功能正常
- [ ] 搜索同时匹配标题和内容

---

## ⚠️ 注意事项

1. **WebSocket测试限制**: 
   - Postman免费版不支持WebSocket
   - 建议使用浏览器控制台或专门的WebSocket测试工具

2. **Redis依赖**: 
   - 确保Redis服务已启动
   - 通知功能依赖Redis存储离线消息

3. **数据库全文搜索**: 
   - MySQL的全文搜索需要表有FULLTEXT索引
   - 如果搜索不工作，可能需要为questions表的title和content字段创建FULLTEXT索引

4. **测试数据**: 
   - 确保数据库中有足够的测试数据
   - 注意userId的对应关系（问题创建者、回答创建者等）

5. **通知清理**: 
   - `GET /notifications/offline/{userId}` 接口会清空该用户的离线通知
   - 测试时注意不要重复调用，否则会丢失之前的通知

---

## 🐛 常见问题排查

### 问题1: WebSocket连接失败
- **检查**: 后端服务是否运行在8081端口
- **检查**: WebSocket URL格式是否正确（`ws://localhost:8081/ws/notifications?userId=3`）
- **检查**: 防火墙是否阻止了WebSocket连接

### 问题2: 搜索无结果
- **检查**: 数据库中是否有包含搜索关键词的问题
- **检查**: MySQL的FULLTEXT索引是否已创建
- **检查**: 关键词是否太短（MySQL全文搜索有最小词长度限制）

### 问题5: 中文显示乱码（显示为问号）
- **原因**: 字符编码配置不正确
- **解决方法**:
  1. **检查数据库字符集**:
     ```sql
     USE learning_db;
     SHOW CREATE DATABASE learning_db;
     -- 应该显示: DEFAULT CHARSET=utf8mb4
     
     SHOW CREATE TABLE questions;
     -- 应该显示: DEFAULT CHARSET=utf8mb4
     ```
  
  2. **如果数据库字符集不是utf8mb4，需要修改**:
     ```sql
     -- 修改数据库字符集
     ALTER DATABASE learning_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
     
     -- 修改表字符集
     ALTER TABLE questions CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
     ALTER TABLE answers CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
     ALTER TABLE users CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
     ALTER TABLE resources CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
     ```
  
  3. **检查application.properties配置**:
     - 确保数据库URL包含: `useUnicode=true&characterEncoding=utf8mb4`
     - 确保服务器编码配置: `server.servlet.encoding.charset=UTF-8`
  
  4. **重新导入数据**（如果数据已经损坏）:
     ```bash
     # 删除并重新创建数据库
     mysql -u root -p -e "DROP DATABASE IF EXISTS learning_db;"
     mysql -u root -p < test_data.sql
     ```
  
  5. **重启后端服务**:
     - 停止当前运行的服务
     - 重新启动Application.java
     - 清除浏览器缓存后重新访问

### 问题3: 通知未触发
- **检查**: Redis服务是否运行
- **检查**: 用户ID是否正确
- **检查**: 后端日志是否有错误信息

### 问题4: 离线通知为空
- **检查**: 是否已经调用过获取离线通知接口（会清空队列）
- **检查**: 用户是否真的离线（如果在线，通知会实时推送，不会存储）
- **检查**: Redis中是否有对应的key（`offline:notifications:{userId}`）

---

## 📚 相关文档

- Postman集合文件: `postman_collection.json`
- WebSocket端点: `ws://localhost:8081/ws/notifications?userId={userId}`
- 后端服务地址: `http://localhost:8081`

